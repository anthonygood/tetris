(()=>{var t={302:(t,e,o)=>{const{countNeighbourValues:i,map:r}=o(803),s=(t,e)=>Number(((t,e)=>3===e||t&&2===e)(t,e)),n=(t,e,o,r)=>s(t,i(e,r));t.exports={countNeighbourValues:i,liveOrDie:s,tick:t=>r(t,n)}},803:t=>{const e=(t,e,o=0)=>Array.from({length:e}).map((()=>new Array(t).fill(o))),o=t=>t.length,i=t=>t[0]?.length,r=(t,e)=>t.forEach(((o,i)=>o.forEach(((r,s)=>e(r,[i,s],o,t))))),s=(t,e)=>t.map(((o,i)=>o.map(((r,s)=>e(r,[i,s],o,t))))),n=t=>t.reduce(((t,e)=>Array.isArray(e)?t.concat(n(e)):t.concat(e)),[]),a=([t,e],o,i)=>{for(let r=t-1;r<=t+1;r++)for(let s=e-1;s<=e+1;s++){if(r===t&&s===e)continue;const n=o[r]&&o[r][s];void 0!==n&&i(n,r,s,o)}},h=(t,e,o)=>{const i=[];return a(t,e,(t=>i.push(o(t)))),i},c=(t,e)=>t.length>e.length?t:e,l=t=>s=>{const n=i(s),a=o(s),h=e(a,n);return r(s,((e,[o,i],r,s)=>{const[c,l]=t(o,i,n,a);h[c][l]=e})),h},d=l(((t,e,o,i)=>[e,i-1-t])),u=l(((t,e,o,i)=>[o-1-e,t])),m=t=>(o,i,r=0)=>{const{length:n}=c(o,i),{length:a}=c(o[0],i[0]);return s(e(a,n),((e,[s,n],a,h)=>t(o[s]?.[n],i[s]?.[n],r)))},p=m(((t,e,o)=>t||e||o)),f=m(((t=0,e=0)=>t+e)),v=m(((t=0,e=0)=>t&&e));t.exports={add:f,blank:e,countNeighbourValues:(t,e)=>((t,e)=>h(t,e,(t=>t)))(t,e).reduce(((t,e)=>t+e),0),debug:(t,e=!1)=>{t.map((t=>e?t.join(","):t)).forEach((t=>console.log(t)))},forEach:r,findIndex:(t,e)=>{for(let o=0;o<t.length;o++)for(let i=0;i<t[o].length;i++)if(e(t[o][i],[o,i],t[o],t))return[o,i]},flatten:n,forEveryNeighbour:a,height:o,intersection:v,map:s,mapNeighbours:h,superimpose:(t,s,n,a,{crop:h}={})=>{const c=i(t),l=o(t),d=e(c,l);return r(s,((t,[e,o],i,r)=>{const s=e+a,u=o+n;if(s>=l||u>=c||s<0||u<0){if(h)return;throw new Error("Superimposed grid would be out of bounds")}d[s][u]=t})),p(t,d)},reduce:(t,...e)=>n(t).reduce(...e),rotateAntiClockwise:u,rotateClockwise:d,union:p,width:i}},702:(t,e,o)=>{const{blank:i,countNeighbourValues:r,forEveryNeighbour:s,map:n}=o(803),a=t=>Math.floor(Math.random()*t.length),h=(t,e,o)=>t>=e&&t<=o,c=([t,e],o)=>{const[i,r]=o;return h(i,t-1,t+1)&&h(r,e-1,e+1)},l=(t,e,o=0,s=[])=>n(((t,e,o=0,r=[])=>{t=Math.max(t,3),e=Math.max(e,3);const s=i(t,e,0);let n=Math.min(o,t*e-9);for(;n;){const t=a(s),e=a(s[t]),o=s[t][e];c(r,[t,e])||1===o||(s[t][e]=1,n--)}return s})(t,e,o,s),((t,e,o,i)=>t?"x":r(e,i))),d=(t,e,o,i)=>{if(-1!==t[o][i])return;const r=e[o][i];return t[o][i]=r,r<1&&s([o,i],e,((e,o,i,r)=>{d(t,r,o,i)})),t},u=t=>{const e=n(t,(()=>-1));return(o,i)=>"x"===t[o][i]?null:(d(e,t,o,i),e)};t.exports={newBoard:l,nextState:u,Minesweeper:class{constructor(t,e,o){this.width=t,this.height=e,this.mineCount=o,this.board=null,this.state=null,this.moves=[]}move(t,e){const{width:o,height:i,mineCount:r}=this;return this.moves.push([t,e]),this.board||(this.board=l(o,i,r,[t,e]),this.next=u(this.board)),"x"!==this.board[t][e]&&(this.state=this.next(t,e),!0)}}}},419:(t,e,o)=>{const i=o(803);Events={},Events.TETROMINO_SPAWN="tetromino:spawn",Events.TETROMINO_LANDING="tetromino:landing",Events.TICK="tick",Events.LINE_CLEAR="lineclear",Events.GAME_OVER="gameover";const r=(t,e,o)=>Math.max(Math.min(o,e),t);class s{constructor(t,e){this.values=[],this.length=t,this.getValFn=e}init(){const{values:t,getValFn:e,length:o}=this;for(;t.length<o;)this.values.unshift(e())}pop(){const{values:t,getValFn:e}=this,o=t.pop();return this.values.unshift(e()),o}}const n=(t,e=t.tetromino,o=t.tetrominoPosition,s=!1)=>{const[n,a]=o,h=i.width(e),c=i.height(e),l=n-t.centre(h),d=a-t.centre(c),u=s?1:0;return[r(0,t.width()-h,l),r(0,t.height()-c+u,d)]},a=(t,e)=>()=>{const o=e(t.tetromino);return!t.detectCollisions(o,...t.tetrominoPosition)&&(t.tetromino=o,!0)};class h{constructor(t=10,e=20,o=!0,n=5){this.board=i.blank(t,e),this.gravityEnabled=o,this.tetromino=null,this.tetrominoPosition=null,this.ticks=0,this.buffer=new s(n,this.randomTetromino),this.bufferSize=n,this.eventListeners={[Events.TICK]:[],[Events.TETROMINO_SPAWN]:[],[Events.TETROMINO_LANDING]:[],[Events.LINE_CLEAR]:[],[Events.GAME_OVER]:[]},this.rotate=a(this,h.Tetromino.rotate),this.rotate.reverse=a(this,h.Tetromino.rotate.reverse),this.clamp={x:r.bind(null,0,t-1),y:r.bind(null,0,e-1)}}getSubscribers(t){const e=this.eventListeners[t];if(!e)throw new Error(`Event '${t}' not supported`);return e}on(t,e){this.getSubscribers(t).push(e)}trigger(t,e){this.getSubscribers(t).forEach((t=>t(e)))}start(){this.buffer.init(),this.spawn()}spawn(t=this.buffer.pop()){if(!t||!t.length||!t[0].length)throw new TypeError("Must provide two dimensional array representing tetromino to spawn");if(this.tetromino=t,this.trigger(Events.TETROMINO_SPAWN,{tetromino:t}),this.tetrominoPosition=[this.centre(),2],!this.detectCollisions(t,...this.tetrominoPosition))return;let e=0;for(;this.detectCollisions(t,...this.tetrominoPosition);)if(this.tetrominoPosition[1]--,e++,e>4)throw new Error(`Spawn failure: ${this.tetrominoPosition}`);this.board=this.compositeBoard(),this.trigger(Events.GAME_OVER,{board:this.board,ticks:this.ticks})}tick(){if(!this.clearLines()){if(this.tetrominoHasReachedBottom()||this.tetrominoHasLandedOnTerrain())return this.trigger(Events.TETROMINO_LANDING,{ticks:this.ticks,tetromino:this.tetromino,position:this.tetrominoPosition,projectedPosition:n(this)}),this.board=this.compositeBoard(),void(this.tetromino=null);this.tetromino?this.gravityEnabled&&(this.tetrominoPosition=this.gravity()):this.spawn(),this.trigger(Events.TICK,{board:this.board,ticks:++this.ticks})}}_move(t,e,o=!1){return!this.detectCollisions(this.tetromino,t,e,o)&&(this.tetrominoPosition=[this.clamp.x(t),this.clamp.y(e)],!0)}get move(){const t=this;return{left(){const[e,o]=t.tetrominoPosition;return t._move(e-1,o)},right(){const[e,o]=t.tetrominoPosition;return t._move(e+1,o)},down:()=>t._move(...t.gravity(),!0)}}fallPosition(){const{tetromino:t,tetrominoPosition:e}=this,[o]=e;let[,i]=e;for(;!this.detectCollisions(t,o,i+1,!0);)i++;return[o,i]}drop(){this.tetrominoPosition=this.fallPosition(),this.tick()}tetrominoGhost(){return this.compositeBoard(i.blank(this.width(),this.height()),this.tetromino,this.fallPosition())}gravity(){const[t,e]=this.tetrominoPosition;return[t,e+1]}detectCollisions(t,e,o,r=!1){const s=i.blank(this.width(),this.height());let a;try{const h=n(this,t,[e,o],r);a=i.superimpose(s,t,...h)}catch(t){return!0}return i.add(this.board,a).flat().some((t=>t>1))}randomTetromino(){const{Tetromino:t}=h,e=[t.L,t.T,t.skew,t.square,t.straight],o=Math.floor(Math.random()*e.length),i=!!Math.floor(2*Math.random()),r=e[o];return i?r.reverse():r()}tetrominoHasLandedOnTerrain(){const{tetromino:t}=this;if(!t)return!1;const e=this.gravity();return this.detectCollisions(t,...e,!0)}tetrominoHasReachedBottom(t=this.tetromino,e=this.tetrominoPosition){if(!t)return!1;const[,o]=n(this,t,e,!0);return o+i.height(t)-1>=this.height()}clearLines(){const t=this.board.filter((t=>t.some((t=>0===t))));if(t.length===this.height())return!1;const e=this.board.reduce(((t,e,o)=>(e.filter(Boolean).length===this.width()&&(t.total+=1,t.indices.push(o)),t)),{ticks:this.ticks,total:0,indices:[],board:{before:[...this.board]}});e.board.completedLines=this.board.map(((t,o)=>{const i=e.indices.includes(o)?1:0;return new Array(this.width()).fill(i)}));const o=i.blank(this.width(),e.total);return this.board=e.board.after=o.concat(t),this.trigger(h.Events.LINE_CLEAR,e),!0}compositeBoard(t=this.board,e=this.tetromino,o=this.tetrominoPosition){if(!e)return t;const r=n(this,e,o);return i.superimpose(t,e,...r)}height(){return i.height(this.board)}width(){return i.width(this.board)}centre(t=this.width()){return Math.floor(t/2)}}const c=t=>i.rotateClockwise(t);c.reverse=i.rotateAntiClockwise;const l=t=>{var e;return fn=()=>t,fn.reverse=(e=t,()=>e.map((t=>[...t].reverse()))),fn},d=l([[1,1,1],[0,1,0]]),u=l([[1,1,1],[1,0,0]]),m=l([[0,1,1],[1,1,0]]),p=l([[1,1],[1,1]]),f=l([[1,1,1,1]]);h.Tetromino={T:d,L:u,skew:m,square:p,straight:f,rotate:c},h.Events=Events,t.exports={Tetris:h}},978:(t,e,o)=>{const i=o(803),r=o(302),{Minesweeper:s}=o(702),{Tetris:n}=o(419);t.exports={Grid:i,GameOfLife:r,Minesweeper:s,Tetris:n}}},e={};function o(i){var r=e[i];if(void 0!==r)return r.exports;var s=e[i]={exports:{}};return t[i](s,s.exports,o),s.exports}(()=>{"use strict";var t=o(978);const e={},i=(t,e)=>{new Array(t).fill(0).forEach(((t,o)=>e(o)))},r=(t,e,o)=>{fn=e?"add":"remove",t.classList[fn](o)},s={left:"KeyA",right:"KeyD",down:"KeyS",rotateRight:"KeyW",rotateLeft:"KeyE",pause:"KeyP"};(()=>{const o=new t.Tetris,{appContainer:n,domCells:a}=((t,e)=>{const o=document.querySelector("#app"),r=document.createElement("div");r.classList.add("grid-container"),o.appendChild(r);const s=[],n=[];return i(t,(t=>{const o=document.createElement("div");o.dataset.i=o.dataset.y=t,o.classList.add("row"),s.push(o);const a=[];i(e,(e=>{const i=document.createElement("div");i.dataset.i=i.dataset.y=t,i.dataset.j=i.dataset.x=e,i.classList.add("cell");const r=document.createElement("div");r.classList.add("interior"),r.classList.add("a");const s=document.createElement("div");s.classList.add("interior"),s.classList.add("b"),i.appendChild(r),i.appendChild(s),o.appendChild(i),a.push(i)})),r.appendChild(o),n.push(a)})),{appContainer:o,domRows:s,domCells:n}})(o.height(),o.width());o.start();const h=((t,e)=>(o=t.compositeBoard())=>{const{tetrominoPosition:i}=t,[s,n]=i,a=t.tetrominoGhost();for(let i=0;i<t.height();i++)for(let h=0;h<t.width();h++){const t=e[i][h];if(!t)return console.error("cell not found at index",i,h);const c=!!o[i][h];r(t,c,"active");const l=a[i][h];r(t,l,"ghost"),r(t,l,"neighbour");const d=a[i-1]?.[h],u=a[i][h-1],m=a[i-1]?.[h-1];r(t,d,"neighbour-top"),r(t,u,"neighbour-left"),r(t,d&&u&&m,"neighbour-top-left");const p=i===n&&h===s;r(t,window.debug&&p,"special")}})(o,a),{start:c,stop:l}=(({tickFn:t,renderFn:o,tickInterval:i,frameInterval:r})=>({start:()=>{e.tickInterval=setInterval(t,i),e.renderInterval=setInterval((()=>requestAnimationFrame((()=>o()))),r)},stop:()=>{clearInterval(e.tickInterval),clearInterval(e.renderInterval)}}))({tickFn:()=>o.tick(),renderFn:h,tickInterval:250,frameInterval:50});o.on(t.Tetris.Events.GAME_OVER,((t,e)=>()=>{e.classList.add("gameover"),t()})(l,n)),o.on(t.Tetris.Events.LINE_CLEAR,((t,e,o,i)=>r=>{const{indices:s,board:n}=r;o(n.before),e(),s.forEach((t=>{i[t].forEach((t=>t.classList.add("flash")))})),setTimeout((()=>{t(),s.forEach((t=>{i[t].forEach((t=>t.classList.remove("flash")))}))}),500)})(c,l,h,a)),o.on(t.Tetris.Events.TETROMINO_LANDING,console.log);const d=((t,e,o)=>i=>{"Escape"===i.code&&(t.paused?e():o(),t.paused=!t.paused)})(o,c,l);document.addEventListener("keydown",(t=>e=>{if(t.paused)return;const{code:o}=e;"ArrowRight"!==o&&o!==s.right||t.move.right(),"ArrowLeft"!==o&&o!==s.left||t.move.left(),"ArrowDown"!==o&&o!==s.down||t.move.down(),"Space"!==o&&o!==s.rotateRight||t.rotate(),o===s.rotateLeft&&t.rotate.reverse(),"Enter"!==o&&o!==s.drop||t.drop()})(o)),document.addEventListener("keydown",d),window.tetris=o,c()})()})()})();